export const makeAsync=e=>{const t={};return{useAsync:(a,s,{expiration:r=36e5}={})=>{const n=(e=>(e in t?console.warn(`Cache for [${e}] exists:`,t[e]):(console.warn(`Creating cache for [${e}] for the first time`),t[e]={status:"initial",expires:0}),t[e]))(a),o=async({optimisticData:t,_shouldRefetch:a,mutation:o}={})=>{if(console.warn("🔥"),"pending"!==n.status)try{void 0!==t&&(n.data=t),n.status="pending",a||e(),o&&await o(n),n.data=await s(t),n.status="success",n.error=void 0,n.expires=Date.now()+r}catch(e){console.error("HERE IS THE ERROR:",e),n.status="error",n.error=e,n.expires=Date.now()+r}finally{e()}else console.warn("❗ Skipped 🔥 due to race condition.")},i=()=>"success"===n.status&&Date.now()<n.expires?n.data:s(),c=()=>n;return{call:e=>{const t="initial"===n.status||Date.now()>=n.expires;return t&&(console.warn("Executing the query for a newly created or expired cache"),o({optimisticData:e,_shouldRefetch:t})),{fire:o,unwrap:i,getCached:c,...n}},fire:o,unwrap:i,getCached:c}}}};
